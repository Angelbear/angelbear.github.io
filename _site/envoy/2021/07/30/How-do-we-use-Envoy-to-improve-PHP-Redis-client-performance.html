<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>How Do We Use Envoy To Improve Php Redis Client Performance - Yangyang’ Blog</title>
<meta name="description" content="Redis plays a very important role in Houzz’s technical stack - we used it for as  key-value storage, caching layer, queue system, etc.">


  <meta name="author" content="Yangyang Zhao">
  
  <meta property="article:author" content="Yangyang Zhao">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yangyang' Blog">
<meta property="og:title" content="How Do We Use Envoy To Improve Php Redis Client Performance">
<meta property="og:url" content="http://localhost:4000/envoy/2021/07/30/How-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html">


  <meta property="og:description" content="Redis plays a very important role in Houzz’s technical stack - we used it for as  key-value storage, caching layer, queue system, etc.">







  <meta property="article:published_time" content="2021-07-30T16:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/envoy/2021/07/30/How-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Yangyang' Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Yangyang' Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="">Engineering</a>
            </li><li class="masthead__menu-item">
              <a href="">Fun & Tools</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="https://avatars.githubusercontent.com/Angelbear" alt="Yangyang Zhao" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Yangyang Zhao</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Senior Staff Site Reliability Engineer</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="mailto:yangyang.zhao.thu@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://thewhip.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Website</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="How Do We Use Envoy To Improve Php Redis Client Performance">
    <meta itemprop="description" content="Redis plays a very important role in Houzz’s technical stack - we used it for as  key-value storage, caching layer, queue system, etc.">
    <meta itemprop="datePublished" content="2021-07-30T16:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">How Do We Use Envoy To Improve Php Redis Client Performance
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>Redis plays a very important role in Houzz’s technical stack - we used it for as  key-value storage, caching layer, queue system, etc.</p>

<p>Redis uses standard TCP protocol for clients to connect to it, to connect to a single Redis instance, the client just need to establish a TCP connection with Redis server, and send raw command using text. You could easily test a connection to Redis server using <code class="language-plaintext highlighter-rouge">telnet</code> command.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bash-3.2$ telnet 127.0.0.1 6379
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
PING
+PONG
</code></pre></div></div>

<h2 id="redis-cluster">Redis Cluster</h2>

<p>As many other storage systems, Redis also has distributed mode -  it is called Redis cluster. The way how Redis scales from 1 instances to muiltiple instances is relying on the KEY hashing. As a key value storage system, Redis cluster will try to distributed all KEYs into different instances based on the CRC hash of the KEY. Each instance in the Redis cluster only stores KEYs within its own slots ranges, and all instances in the Redis custer will cover the whole range of CRC hash which is [0, 16384].</p>

<p>Redis also support primary / secondary mode which could provides data redudancy and seperate read/update opertions. Each slot range can have 1 primary instance, with 1 or more replica instances storing the same KEYs.</p>

<p><img src="/assets/imgs/redis_cluster.svg" alt="Redis Cluster" /></p>

<p>The operations on single Redis instance varies from it on Redis cluster. To use single Redis instance, we just connect to the single socket address, to use a Redis cluster, we would need to have more complicated logic. Typically, a Redis cluster client need to support the following features:</p>

<ol>
  <li>Automatically discover cluster topology. Since KEYs are stored in different Redis server instances, the Redis cluster client has to know which slot range is stored in which Redis server instances (including primary / replicas). Redis cluster provides a <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> command that can return the server topology with arrays of slot range and primary/replica socket addresses. To execute the <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> command, the Redis cluster client need to know at least the address of 1 nodes in the Redis cluster topology, which is usually passed in as start probe address(es) when inititalizing the client instance.</li>
  <li>On demand dispatch commands to Redis server instance. When using Redis cluster client to send a command that carries KEY(s) parameter to the Redis cluster, the client has to determine which Redis server instance(s) should the command to sent to. How to detemine them is based on the server topology fetcher in previous step, to calculate the CRC hash of the KEY(s), then find the slot range that the KEY resides, and then based on the read / write policy, to send the command to the primary / replica Redis server instance of the slot range that the KEY belongs to. For some commands operating multiple KEYs (e.g. mget, mset, etc), the client has to split the single multiple key command into several batches based on the slot range group of the KEYs, and send the command with each group’s KEYs to the corresponding Redis server instance, and merge the results from all instances. Some client libraries didn’t implement this “advanced” feature, therefore they declare they don’t support multi-key commands with keys across slots.</li>
</ol>

<p>There are already a lot of <a href="https://redis.io/clients">Redis client libraries</a> developed in different languages that could help to mitigate the difference of connecting to a single Redis client or Redis cluster.  In most of the senarios, programmers won’t notice the difference of using single Redis instance or Redis cluster, since the complexity is capsulated by the client libraries.</p>

<h2 id="php-redis-cluster-client-and-the-problem">PHP Redis Cluster Client and the Problem</h2>

<p>A single Redis instance can satisfy the small use cases, at the scale of supporting Houzz’s business, we have to Redis cluster vs single Redis instance since we’ve stored TBs data in Redis and it has to be distributed into different instances.</p>

<p>As the time of 2021, we’ve setup a Redis cluster with 200+ instances, with primary / replica enabled, to make sure we have data redundancy and ability to recover from single instance failure.</p>

<p>As historical reasons, Houzz’s major programming language is PHP, it is still one of the most popular programming language in web development. And we use <a href="https://github.com/predis/predis">predis</a>, a widely used PHP Redis client that supports Redis cluster, it provides the feature such as automatic cluster topology discovery and on demand dispatch commands to Redis server instance.</p>

<p>Funtionality wise, we are satisified with the PHP redis client, however, the nature of PHP language itself gives us very big challange on the performance side.</p>

<p>Unlike Java, Python or Node server applications, PHP process does not share data between subsequent requests. Once PHP handles a web request, it will discard all the data before it’s ready to handle the next request.</p>

<p>Why does this hurt the performance of the Redis cluster client?</p>

<p>First of all, the cluster topology will not be shared across requests. Suppose predis first connect to one of the start probe redis server instance, send <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> command, and got the cluster topology in the handling of one request, the topology, which is usually a nested <code class="language-plaintext highlighter-rouge">array</code> in memory will not be used in the next request. Therefore, in the next request, predis has to connect to one of the start probe again, and send <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> again to get the cluster topology. This is exremely ineffective since Redis cluster topology rarely changes (usually it only changes when we take some redis nodes down or add new redis nodes, which will cause a rebalance). The extra <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> command usually add up 4 ~ 5 ms to the redis access time per request, if in the request, there are only 1 redis operation needed, then we added 100% overhead than it’s supposed to be.</p>

<p>Another nature behavior of PHP process is that, you can not persist any TCP connections between two requests.</p>

<p><img src="/assets/imgs/redis_connection.svg" alt="Redis Connection" /></p>

<p>As described in the above graph, suppose we have 2 PHP processes running on a single machine, with 2 requests been handled per process, and each request will need to connect to 2 Redis server instances. The subsequantial requests handled by the same process will connect to the same redis server instance, yet since the previous request’s TCP connection is closed, it can not be reused, so even it connects to the same socket address (of the Redis server instance), it has to create another TCP connection.</p>

<p>So as a PHP process is handling more and more requests, it creates / closes more and more TCP connections to Redis clusters. Compared to other languages which could maintain persistent TCP connections in the process, this is already a big performance loss.</p>

<p>Another more critical problem is, a TCP connection’s termination is not a direct close and not releasing the resource immediately.</p>

<p><img src="/assets/imgs/tcp.svg" alt="TCP lifecycle" /></p>

<p>As described in the above graph, in active close mode, when the TCP connection initiator (in this case the PHP redis cluster client) started to close the the connection, it sends a <code class="language-plaintext highlighter-rouge">FIN</code> packet through the TCP connection, the TCP connectino receiver (Redis cluster instance) will need to send <code class="language-plaintext highlighter-rouge">ACK</code> + <code class="language-plaintext highlighter-rouge">FIN</code> packet back. Due to the nature of TCP connection, initiator will turn into <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> status until finally it timeout and connection is finally closed, the TCP connection resource is recycled by system.</p>

<p>Due to the PHP Redis cluster client access pattern, it keeps creating new TCP connections to PHP Redis cluster instances and closes them immediately after 1 session ends. Due to the QPS of our production traffic volume to 1 box, it leaves too many  <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> TCP connections in the box. Once <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> TCP connections pile up, new TCP connections are slower to be created, thus making Redis cluster client to be slower, and causing web request responding time to increase, more requests are stucking. In the end, it reaches the threshold that Redis cluster client failed to create TCP connections within the timeout settings time (4s), and it will throw an error saying Redis server is down.</p>

<p>We noticed this issue from last year when our access volume significant increased (from business perspective it’s a very good sign!), and we were seeing more errors complaining about Redis server down and performance degradation during the peek hours.  But Redis servers actually are not on high pressure at all, the bottleneck is purely from the TCP connections from the client side. While to solve this, every time SRE team has to increase the instances of our application boxes, which is unnessasary, and a waste of our computing resources.</p>

<h2 id="finding-solutions">Finding Solutions</h2>

<p>If you google/stackoverflow “too many TIME_WAIT tcp connections” keywords, some of the blogs will lead to the following solution: Enable tcp resuse feature to reduce the <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> TCP connections.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sysctl -w net.ipv4.tcp_tw_reuse=1
</code></pre></div></div>
<p>We believed this would work, and added this option to the system default setting of our production boxes, however, it didn’t help. The TCP connections in <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> state are still high.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@web-server:/# sysctl net.ipv4.tcp_tw_reuse=1
net.ipv4.tcp_tw_reuse = 1
root@web-server:/# ss -tan state time-wait | grep 6379 | wc -l
70145
</code></pre></div></div>
<p>Inspired by <a href="https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#netipv4tcp_tw_reuse">Coping with the TCP TIME-WAIT state on busy Linux servers</a> blog post, we think we found the reason why it didn’t work.</p>

<blockquote>
  <p>By enabling net.ipv4.tcp_tw_reuse, Linux will reuse an existing connection in the TIME-WAIT state for a new outgoing connection if the new timestamp is strictly bigger than the most recent timestamp recorded for the previous connection: an outgoing connection in the TIME-WAIT state can be reused after just one second.</p>
</blockquote>

<p>Within “Just one second”, since the QPS of the box is around 100, it will probably create ~ 100 (avg QPS) * 50 (avg # of redis connections in 1 request) = 5,000 new TCP connections, and these 5K connections can not reuse the <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> connections left intact in the exact second. Before it could benefit from the tcp reuse mechanism, the too many <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> TCP connections hold up the kernal from creating new TCP connections, thus this didn’t help much.</p>

<h2 id="envoy--envoy-redis-cluster">Envoy / Envoy Redis Cluster</h2>

<p>Since the year of 2020, we introduced Istio as our service mesh solution to our Kubernetes cluster, and it started to play as the proxy for all network traffic from / to our web application container.</p>

<p>Envoy, as the proxy implementation of Istio, provides a lot of features that helps the abstract the networking logic from application code.</p>

<p>One inspiring feature that Envoy provides in the newer versions, which is the final solution we used for solving this issue, is <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis#redis-cluster-support-experimental">Redis Cluster support</a>.</p>

<blockquote>
  <p>When using Envoy as a sidecar proxy for a Redis Cluster, the service can use a non-cluster Redis client implemented in any language to connect to the proxy as if it’s a single node Redis instance. The Envoy proxy will keep track of the cluster topology and send commands to the correct Redis node in the cluster according to the spec. Advance features such as reading from replicas can also be added to the Envoy proxy instead of updating redis clients in each language.</p>

  <p>Envoy proxy tracks the topology of the cluster by sending periodic cluster slots commands to a random node in the cluster, and maintains the following information:</p>

  <ul>
    <li>List of known nodes.</li>
    <li>The primaries for each shard.</li>
    <li>Nodes entering or leaving the cluster.</li>
  </ul>
</blockquote>

<p>With this feature enabled, mthe PHP Redis client’s cluster related logic will be taken over by Envoy. PHP Redis client only need to create one connection to the proxied Redis instance provided by Envoy.</p>

<p>It took us for a while to figure out how exactly to configure the Envoy Redis cluster proxy, due to the lack of examples provided. But we finally figured out the configuration, first of all, we need to create a backend cluster.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">EnvoyFilter</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">redis-cluster-backend</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">configPatches</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">applyTo</span><span class="pi">:</span> <span class="s">CLUSTER</span>
    <span class="na">patch</span><span class="pi">:</span>
      <span class="na">operation</span><span class="pi">:</span> <span class="s">INSERT_FIRST</span>
      <span class="na">value</span><span class="pi">:</span>
        <span class="na">cluster_type</span><span class="pi">:</span>
          <span class="na">name</span><span class="pi">:</span> <span class="s">envoy.clusters.redis</span>
          <span class="na">typed_config</span><span class="pi">:</span>
            <span class="s1">'</span><span class="s">@type'</span><span class="pi">:</span> <span class="s">type.googleapis.com/google.protobuf.Struct</span>
            <span class="na">value</span><span class="pi">:</span>
              <span class="na">cluster_refresh_rate</span><span class="pi">:</span> <span class="s">1800s</span>
              <span class="na">cluster_refresh_timeout</span><span class="pi">:</span> <span class="s">4s</span>
              <span class="na">host_degraded_refresh_threshold</span><span class="pi">:</span> <span class="m">1</span>
              <span class="na">redirect_refresh_interval</span><span class="pi">:</span> <span class="s">4s</span>
              <span class="na">redirect_refresh_threshold</span><span class="pi">:</span> <span class="m">1</span>
        <span class="na">connect_timeout</span><span class="pi">:</span> <span class="s">4s</span>
        <span class="na">dns_lookup_family</span><span class="pi">:</span> <span class="s">V4_ONLY</span>
        <span class="na">load_assignment</span><span class="pi">:</span>
          <span class="na">cluster_name</span><span class="pi">:</span> <span class="s">custom-redis-cluster</span>
          <span class="na">endpoints</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">lb_endpoints</span><span class="pi">:</span>
            <span class="pi">-</span> <span class="na">endpoint</span><span class="pi">:</span>
                <span class="na">address</span><span class="pi">:</span>
                  <span class="na">socket_address</span><span class="pi">:</span>
                    <span class="na">address</span><span class="pi">:</span> <span class="s">&lt;redis instance 1 ip&gt;</span>
                    <span class="na">port_value</span><span class="pi">:</span> <span class="s">&lt;redis instance 1 port&gt;</span>
            <span class="pi">-</span> <span class="na">endpoint</span><span class="pi">:</span>
                <span class="na">address</span><span class="pi">:</span>
                  <span class="na">socket_address</span><span class="pi">:</span>
                    <span class="na">address</span><span class="pi">:</span> <span class="s">&lt;redis instance 2 ip&gt;</span>
                    <span class="na">port_value</span><span class="pi">:</span> <span class="s">&lt;redis instance 1 port&gt;</span>
            <span class="pi">-</span> <span class="na">endpoint</span><span class="pi">:</span>
                <span class="na">address</span><span class="pi">:</span>
                  <span class="na">socket_address</span><span class="pi">:</span>
                    <span class="na">address</span><span class="pi">:</span> <span class="s">&lt;redis instance 3 port&gt;</span>
                    <span class="na">port_value</span><span class="pi">:</span> <span class="s">&lt;redis instance 3 port&gt;</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">redis-cluster-backend</span>
        <span class="na">outlier_detection</span><span class="pi">:</span>
          <span class="na">base_ejection_time</span><span class="pi">:</span> <span class="s">20s</span>
          <span class="na">consecutive_5xx</span><span class="pi">:</span> <span class="m">1</span>
          <span class="na">interval</span><span class="pi">:</span> <span class="s">5s</span>
        <span class="na">upstream_connection_options</span><span class="pi">:</span>
          <span class="na">tcp_keepalive</span><span class="pi">:</span>
            <span class="na">keepalive_interval</span><span class="pi">:</span> <span class="m">5</span>
            <span class="na">keepalive_probes</span><span class="pi">:</span> <span class="m">1</span>
            <span class="na">keepalive_time</span><span class="pi">:</span> <span class="m">30</span>
</code></pre></div></div>

<p>In the backend settings, the most important settings is the <code class="language-plaintext highlighter-rouge">load_assignment</code>, it basically describes the startuo probe nodes that envoy will send <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> command to get the cluster topology.</p>

<p>There are definitely quite a few settings worth being tuned to get better performance:</p>

<ol>
  <li><strong>cluster_refresh_rate</strong>:  This is the interval between <code class="language-plaintext highlighter-rouge">CLUSTER SLOTS</code> commands sent from envoy to startup probe nodes. Typically redis cluster topology won’t change that frequently, so we could set this value much longer than default value (5s)</li>
  <li><strong>host_degraded_refresh_threshold</strong>: The number of hosts became degraded or unhealthy before triggering a topology refresh request. This is very helpful, since we will configure <code class="language-plaintext highlighter-rouge">cluster_refresh_rate</code> to be as long as possible, once the redis cluster topology changed between two refresh, this config setting to a low value (1 for most aggresive) will immediately let Envoy to send <code class="language-plaintext highlighter-rouge">CLUSTER SLOS</code> command to get the new topology, to remove potential problematic node out of the connection pools.</li>
  <li><strong>redirect_refresh_threshold</strong>: The number of redirection errors that must be received before triggering a topology refresh request. Sometimes, when we add / remove nodes from Redis cluster, the key will rebalance among the new cluster instances, it will cause some response to be <code class="language-plaintext highlighter-rouge">MOVED</code> or <code class="language-plaintext highlighter-rouge">ASK</code>, in this case, we should let Envoy to send <code class="language-plaintext highlighter-rouge">CLUSTER SLOS</code> command to get the new topology immeidately.</li>
  <li><strong>outlier_detection</strong>: <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier">Outlie detection</a> is unified mechanism in Envoy to detect outlited upstream hosts. In Envoy Redis cluster, an upstream means 1 redis cluster server in the topology. Suppose a redis cluster node was suddenly down, the following request to the node will get ERR response. The <code class="language-plaintext highlighter-rouge">consecutive_5xx</code> setting is the threshold of ERR responses in past <code class="language-plaintext highlighter-rouge">interval</code> time so as to consider the node to be unhealthy. Once the node is considered unhealthy, it will be taken out of the upstream servers, and will tried to be put back after <code class="language-plaintext highlighter-rouge">base_ejection_time</code>, and exponentially backoff in following degradations.</li>
  <li><strong>upstream_connection_options</strong>: This is mostly for tuning the keep alive setting for TCP connections between Envoy and Redis cluster nodes. Envoy will on demandly connect to Redis cluster nodes if PHP client tries to send a command to the destination nodes, after the command is sent, the connection remains <code class="language-plaintext highlighter-rouge">ESTABLISED</code> state. But if the connnection stays too long time without sending any packages to Redis cluster node, it might be closed by the Redis cluster node, in order to extend the life of the TCP connection, we could configure Envoy sending keepalive packet to Redis cluster node after <code class="language-plaintext highlighter-rouge">keepalive_time</code> since the connection is established, and set it to send <code class="language-plaintext highlighter-rouge">keepalive_probes</code> times keepalive interval with <code class="language-plaintext highlighter-rouge">keep_alive</code> interval.</li>
</ol>

<p>We also need to create a frontend in Envoy to let the PHP client in main container to connect.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">EnvoyFilter</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">redis-cluster-frontend</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">configPatches</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">applyTo</span><span class="pi">:</span> <span class="s">LISTENER</span>
    <span class="na">match</span><span class="pi">:</span>
      <span class="na">context</span><span class="pi">:</span> <span class="s">SIDECAR_OUTBOUND</span>
    <span class="na">patch</span><span class="pi">:</span>
      <span class="na">operation</span><span class="pi">:</span> <span class="s">ADD</span>
      <span class="na">value</span><span class="pi">:</span>
        <span class="na">address</span><span class="pi">:</span>
          <span class="na">socket_address</span><span class="pi">:</span>
            <span class="na">address</span><span class="pi">:</span> <span class="s">127.0.10.1</span>
            <span class="na">port_value</span><span class="pi">:</span> <span class="m">6379</span>
            <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
        <span class="na">filter_chains</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">filters</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">envoy.filters.network.redis_proxy</span>
            <span class="na">typed_config</span><span class="pi">:</span>
              <span class="s1">'</span><span class="s">@type'</span><span class="pi">:</span> <span class="s">type.googleapis.com/envoy.extensions.filters.network.redis_proxy.v3.RedisProxy</span>
              <span class="na">prefix_routes</span><span class="pi">:</span>
                <span class="na">catch_all_route</span><span class="pi">:</span>
                  <span class="na">cluster</span><span class="pi">:</span> <span class="s">redis-cluster-backend</span>
              <span class="na">settings</span><span class="pi">:</span>
                <span class="na">enable_hashtagging</span><span class="pi">:</span> <span class="no">true</span>
                <span class="na">enable_redirection</span><span class="pi">:</span> <span class="no">true</span>
                <span class="na">op_timeout</span><span class="pi">:</span> <span class="s">4s</span>
                <span class="na">read_policy</span><span class="pi">:</span> <span class="s">PREFER_REPLICA</span>
              <span class="na">stat_prefix</span><span class="pi">:</span> <span class="s">redis_proxy</span>
        <span class="na">name</span><span class="pi">:</span> <span class="s">redis-cluster-frontend</span>
</code></pre></div></div>

<p>The above configuraion creates a Redis proxy frontend on <code class="language-plaintext highlighter-rouge">127.0.10.1:6379</code>. This address is available to the other containers aside from istio-proxy. The most importan config, is <code class="language-plaintext highlighter-rouge">prefix_routes.catch_all_route</code> to <code class="language-plaintext highlighter-rouge">redis-cluster-backend</code> cluster which is the exact backend cluster we created before. The config of proxy frontend is relatively simple, with fewer settings could be tuned, one important setting is <code class="language-plaintext highlighter-rouge">read_policy</code>, we chose <code class="language-plaintext highlighter-rouge">PREFER_REPLICA</code> to achive the functional parity as the original PHP Redis cluster client’s logic - when reading from redis (get, mget, etc), always try to read from replica nodes, only read from primary nodes when all replica nodes for the slots were not available.</p>

<p><img src="/assets/imgs/istio.svg" alt="Envoy Proxy Cluster" /></p>

<p>The above graph directly shows the magic why using Envoy Redis cluster proxy could save TCP connections.</p>

<p>Before, suppose in 1 request handling process PHP Redis client needs to connect to X Redis cluster instaces, it has to create X TCP connections from main web server container to istio-proxy container, and envoy has to create corresponding X TCP connections from istio-proxy container to Redis cluster instances.</p>

<p>After using the Envoy Redis cluster proxy, PHP client only needs to connect to the frontend proxy in istio-proxy container, and Envoy will “smartly” dispatch the commands to proxy backend, and create connections to X Redis cluster servers.</p>

<p>We saved X - 1 TCP connections for one request handled by the PHP process. What’s more, the X connections created between Envoy Redis cluster proxy backend and the real Redis cluster services are persistent connections, they do not close after the PHP process finished handling 1 request. Also, other requests handled by other PHP processes in the main web server container could also reuse the connections since the frontend and backend is seperated. These all leads to a huge save of TCP connections.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@web-server:/# ss -tan state time-wait | grep 6379 | wc -l
3108
</code></pre></div></div>

<p>By doing this, we broke the nature limitation of PHP language, we reduced <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> tcp connections by 95%!</p>

<p>Also, we see great reduce of average redis connection time per request dropped from ~5ms to nearly 0ms! This is contributed by:</p>

<ol>
  <li>Much fewer connections needs to be made since all commands are sent to to the same frontend proxy by PHP client, thus only 1 connection needs to be created per requet.</li>
  <li>Connection to the frontend is via local network (from main container to istio-proxy container), which is much stable and lightweighted.</li>
</ol>

<p>We roll out this solution 100% on our production k8s clusters, and indeed, it solved the bottleneck of <code class="language-plaintext highlighter-rouge">TIME_WAIT</code> TCP connections, and enabled our Pods to be able to take more traffic. It also leads to some save of the k8s resources.</p>

<h2 id="caveats">Caveats</h2>

<p>While we talked all good things about Envoy Redis cluster proxy, there are certainly some caveats for using it.</p>

<h3 id="read--write-performance-degradation">Read / Write performance degradation</h3>
<p>We mentioned the average TCP connection time reduced from ~ 5m to nearly 0ms in the last chapter. But for read / write redis operations, the performance degradated a bit. This is easy to understand. Envoy still needs to create the TCP connections to Redis cluster nodes, and it still needs to send the command packages to the nodes, and receive the responses, even more logic was added to dispatch commands to the correct node(s) and aggregate responses from multiple nodes (e.g. mget, mset). This degradation was more obvious for sparse request when the TCP connection reuse in the proxy backend wasn’t giving much benefit.</p>

<p>We noticed this consistent performance degradation while we were finally OK with it - the overall average read / write time was fast enough comparing to rest of PHP code logic.</p>

<h3 id="lack-of-retry-logic">Lack of retry logic</h3>

<p>There was an very important feature in the old PHP Redis Cluster client, which is the auto retry logic.</p>

<p>Generally for each shard of the Redis cluster, it consists of 1 primary node and 2 replica nodes. When PHP Redis cluster client is to send a read command, it first will pick a random replica to send the command, if the command failed due to network commnunication issue, it will retry to send the command to the other replica node, if it still fails, it will ultimately send the command to the primary node.</p>

<p>This logic is straightforward and is very helpful to mitigate the downtime. Suppose we are doing a rolling restart of the whole Redis cluster, typically we will restart 1 node at one time, the retry logic will make sure the request can still be properly handled.</p>

<p>Unfortunately, Built-in retry logic is still on the <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/other_protocols/redis">planned future features list</a> at the moment of Mid 2021, as we tested putting down 1 replica node in 1 shard, we noticed there were around 10 seconds downtime when we see client errors of “no upstream hosts” from Envoy. This down time could be mitigated by tuning the <code class="language-plaintext highlighter-rouge">outlier_detection</code> settings, when the node is down, subsequential requests to the specific node will be errored out, after the <code class="language-plaintext highlighter-rouge">outlier_detection.interval</code> time, it will be taken out of the upstreams and Envoy will stop sending any more commands to this node.</p>

<p>Currently there is no good way to bypass this issue. Even we retry within the PHP client, the PHP client couldn’t decide which Redis cluster node that Envoy will connect.</p>

<p>We lived with this lack of retry logic, and rely on the <code class="language-plaintext highlighter-rouge">outlier_detection</code> mechanism to mitigate the downtime, and we really hope the built-in retry logic could be supported soon.</p>

<h3 id="too-many-established-connections">Too many ESTABLISHED connections</h3>

<p>This is a problem we forsee, that before our PHP clients create TCP connections to Redis cluster nodes, and disconnect soon after the request is processed. The “come and go” pattern actually has a benefit that overall Redis cluster nodes do not have too many <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> connections from the clients.</p>

<p>Ever since we start testing using Envoy Redis cluster proxy, we immediately noticed dramatic increase of <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> connections from the Redis server nodes. The increased persistent connections have been impacted the connection performance - if 1 Redis cluster node has been connected by too many clients, newer connections will be hard to made.</p>

<p>To improve this, we tuned down <code class="language-plaintext highlighter-rouge">timeout</code> setting in redis.conf on the Redis server side from 300 seconds to half of the value, and it helped to reduce 30% of the <code class="language-plaintext highlighter-rouge">ESTABLISHED</code> connections in our workload. The <code class="language-plaintext highlighter-rouge">timeout</code> setting let Redis server side to close the connection after a client is idle for that long time. However, there is always the trade off - The shorter we configured the <code class="language-plaintext highlighter-rouge">timeout</code> setting, the more likely Envoy will have to connect more frequently to Redis cluster nodes, and impact the overall Redis client performance.</p>

<p>Another solution, is to increase the Redis cluster nodes number, so average connections to 1 Redis cluster nodes will drop, however, this will cause unessasary resource waste if Redis workload is not high on each node.</p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-07-30T16:00:00+08:00">July 30, 2021</time></p>


      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?text=How+Do+We+Use+Envoy+To+Improve+Php+Redis+Client+Performance%20http%3A%2F%2Flocalhost%3A4000%2Fenvoy%2F2021%2F07%2F30%2FHow-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fenvoy%2F2021%2F07%2F30%2FHow-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fenvoy%2F2021%2F07%2F30%2FHow-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="#" class="pagination--pager disabled">Previous</a>
    
    
      <a href="/istio/2023/11/20/Introduction.html" class="pagination--pager" title="Introduction
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You May Also Enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Tuning-Istio.html" rel="permalink">Tuning Istio
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Some of the new users of service mesh solutions including myself may think that network connections would be improved by just introducing the solution. This ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/L4-Vs-L7.html" rel="permalink">L4 Vs L7
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">As many of the students who have studied computer science, networking is definitely a part that is very important, but easy to forget after graduation.

</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Istio-Vs-Envoy.html" rel="permalink">Istio Vs Envoy
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">If you looked at the documentation of Istio, this terminology envoy appears multiple ones. Also, there are some concepts like EnvoyFilter  that you might com...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Introduction.html" rel="permalink">Introduction
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">I started to get in touch with Istio from 2020, when the Istio version was still around 1.6-ish. I was not the person who introduced Istio to the company, th...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Yangyang' Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
