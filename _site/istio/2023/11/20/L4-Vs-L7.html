<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>L4 Vs L7 - Yangyang’ Blog</title>
<meta name="description" content="As many of the students who have studied computer science, networking is definitely a part that is very important, but easy to forget after graduation.">


  <meta name="author" content="Yangyang Zhao">
  
  <meta property="article:author" content="Yangyang Zhao">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Yangyang' Blog">
<meta property="og:title" content="L4 Vs L7">
<meta property="og:url" content="http://localhost:4000/istio/2023/11/20/L4-Vs-L7.html">


  <meta property="og:description" content="As many of the students who have studied computer science, networking is definitely a part that is very important, but easy to forget after graduation.">







  <meta property="article:published_time" content="2023-11-20T18:00:00+08:00">






<link rel="canonical" href="http://localhost:4000/istio/2023/11/20/L4-Vs-L7.html">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": null,
      "url": "http://localhost:4000/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Yangyang' Blog Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Yangyang' Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="">Engineering</a>
            </li><li class="masthead__menu-item">
              <a href="">Fun & Tools</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="https://avatars.githubusercontent.com/Angelbear" alt="Yangyang Zhao" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Yangyang Zhao</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Senior Staff Site Reliability Engineer</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li><a href="mailto:yangyang.zhao.thu@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://thewhip.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Website</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="L4 Vs L7">
    <meta itemprop="description" content="As many of the students who have studied computer science, networking is definitely a part that is very important, but easy to forget after graduation.">
    <meta itemprop="datePublished" content="2023-11-20T18:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">L4 Vs L7
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minute read
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>As many of the students who have studied computer science, networking is definitely a part that is very important, but easy to forget after graduation.</p>

<p>All the modern frameworks in different languages hide the details of networking from you, and you can use just 3 lines to make a HTTP call in Python.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p>You take for granted that this is the ability provided, and may never remember those terminologies like physical layer, TCP handshake, etc. (Unless one day you were asked the question <a href="https://www.linkedin.com/pulse/what-happens-when-you-type-googlecom-your-browser-press-sule-bala/">What happens when you type google.com in your browser and press Enter</a>)</p>

<p>We are not going to cover that many details about networking in this article. But there is a key quesition that we should be able to answer, why do we introduce Istio for the first place?</p>

<p>Stories may vary for different organization, but I guess the main purpose of introducing Istio should have <strong>better</strong> traffic management in Kubernetes. The word “better” was emphasized because it’s not that kubernetes can not do traffic management. Kubernetes does provide traffic management, and in most senarios it works fine so that you do not need a better solution.</p>

<p>What exactly is Traffic Management in Kubernetes? Simply speaking, to control how requests will be routed to Pods.</p>

<p>Let’s take a look at a simple example. We first create a kubernetes deployment of nginx,</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:latest</span>
</code></pre></div></div>
<p>and create corresponding service for accessing the nginx http server.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Service</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">protocol</span><span class="pi">:</span> <span class="s">TCP</span>
      <span class="na">port</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">targetPort</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">type</span><span class="pi">:</span> <span class="s">ClusterIP</span>
</code></pre></div></div>

<p>Three <code class="language-plaintext highlighter-rouge">nginx-deployment</code> pods will be created, and you try to test the nginx service by typing <code class="language-plaintext highlighter-rouge">curl http://nginx-service.namepace.svc.cluster.local</code> in any pod on the same kubernetes cluster. It would output “It Works!” as the default nginx response.</p>

<h2 id="traffic-management---load-balancing">Traffic Management - Load balancing</h2>

<p>How did the <code class="language-plaintext highlighter-rouge">curl</code> commmand reached the <code class="language-plaintext highlighter-rouge">nginx-deployment</code> pods? The <code class="language-plaintext highlighter-rouge">curl</code> command uses HTTP protocol, and it needs to establish a TCP connection to <code class="language-plaintext highlighter-rouge">nginx-service.namepace.svc.cluster.local</code> with <code class="language-plaintext highlighter-rouge">80</code> port. Since there are three <code class="language-plaintext highlighter-rouge">nginx</code> Pods, how does kubernetes decide which Pod’s nginx to connect?</p>

<p>Let’s see how it is working without Istio.  As the native kubernetes service implementation, <code class="language-plaintext highlighter-rouge">kube-proxy</code> is responsible for the decision. Once <code class="language-plaintext highlighter-rouge">nginx-service</code> is created, <code class="language-plaintext highlighter-rouge">kube-proxy</code> takes care of following things:</p>

<ol>
  <li>It creates IP address for the <code class="language-plaintext highlighter-rouge">nginx-service</code> and persist the record to kube-dns / core-dns, so when curl tries to resolve <code class="language-plaintext highlighter-rouge">nginx-service.namepace.svc.cluster.local</code> it will get an dedicated Service IP.</li>
  <li>Whenever a <code class="language-plaintext highlighter-rouge">nginx</code> Pod is created / deleted, become ready / unready, <code class="language-plaintext highlighter-rouge">kube-proxy</code> needs to add / remove the Pod from / to available candidates for <code class="language-plaintext highlighter-rouge">nginx-service</code>.</li>
  <li>Whenever a TCP connection is to be established to the service IP / port, <code class="language-plaintext highlighter-rouge">kube-proxy</code> needs to select one candidate from its internal maintained list.</li>
</ol>

<p>This is so-called “Load Balancing”. The load balancing strategy may varies in different kubernetes versions, in high level it will do sort of “round robin” to let each of the Pod to be able to receive connections with even possibility (at best effort).</p>

<h3 id="l4-layer-load-balancing---kube-proxy">L4 layer load balancing - kube-proxy</h3>

<p>The above process generally works well for most of the senarios. If you get 30 QPS requests to the <code class="language-plaintext highlighter-rouge">nginx-service</code>, theoritically it should have ~ 10 QPS requests to each of the <code class="language-plaintext highlighter-rouge">nginx-deployment</code> Pod.</p>

<p>But in reality, you may find QPS is not evenly distributed in the 3 <code class="language-plaintext highlighter-rouge">nginx-deployment</code> Pod, in some extreme cases, 1 Pod may get 30 QPS requests while other 2 Pods don’t get traffic at all.</p>

<p>How does it happen?</p>

<p>HTTP Protocol relies on TCP connections, so 1 HTTP request means we need to have 1 TCP connection. But it’s not like every HTTP request has to create a new TCP connection. There is this “Keep Alive” mechanism that a client can establish 1 TCP connection and reuse it for multiple HTTP requests.</p>

<p><img src="http://localhost:4000/assets/imgs/03-http-imbalanced.svg" alt="HTTP Imbalanced Trffic" style="display: block; width: 75%; margin: auto; background: white;" /></p>

<p>The above graph can directly simulate the actual traffic from different clients to different nginx pods. Although the TCP connections are evenly distributed, but actual HTTP requests are not.</p>

<p>This is exactly the bottleneck of kubernete’s native traffic management - it only works at <strong>L4 (Transport) Layer</strong>, while HTTP protocol is at <strong>L7 (Application) Layer</strong>. Once TCP connections are established, kubernetes lose the control how the client will use the connection, such as protocol, frequency, etc.</p>

<h3 id="l7-layer-load-balancing---istio">L7 layer load balancing - Istio</h3>

<p>How things would be different if we adapt Istio?</p>

<p>If we adapted istio and enabled the proxy injection in both service and client pods, we will see that <code class="language-plaintext highlighter-rouge">istio-proxy</code> container will be injected into the pods. Every single TCP connections from and to the pod will be intercepted.</p>

<p>As described in <a href="02-Istio-Vs-Envoy.md">Istio VS Envoy</a>, <code class="language-plaintext highlighter-rouge">envoy</code> does the the real job to establish the TCP connections to both side.</p>

<p>Essentially <code class="language-plaintext highlighter-rouge">envoy</code> needs to do the same job as <code class="language-plaintext highlighter-rouge">kube-proxy</code>, but it does not rely on <code class="language-plaintext highlighter-rouge">kube-proxy</code>, instead it implemented its ownd mechanism to do the service dns resolve, maintain the active candidates of Pods, and do the choice of pod for TCP connection.</p>

<p>But <code class="language-plaintext highlighter-rouge">envoy</code> does a bit more than that, <code class="language-plaintext highlighter-rouge">envoy</code> maintains the TCP connections to both sides, not not nessasarily a 1:1 mapping.</p>

<p>Look at the following graph as the example, client app tries to connect to <code class="language-plaintext highlighter-rouge">nginx-service.namepace.svc.cluster.local</code>, and <code class="language-plaintext highlighter-rouge">envoy</code> in <code class="language-plaintext highlighter-rouge">istio-proxy</code> established the TCP connection between itself and the client process. But on the other hand, <code class="language-plaintext highlighter-rouge">envoy</code> would create (or reuse) 1 or more TCP connections between itself and <code class="language-plaintext highlighter-rouge">nginx-deployment</code> Pods.</p>

<p><img src="http://localhost:4000/assets/imgs/03-http-balanced.svg" alt="HTTP Imbalanced Trffic" style="display: block; width: 70%; margin: auto; background: white;" /></p>

<p>Later on, when clint process tries to send GET http requests, <code class="language-plaintext highlighter-rouge">istio-proxy</code> would use some strategy to forward the requests to differnt TCP connections with <code class="language-plaintext highlighter-rouge">nginx-deployment</code> Pods. As a result, even the client pods may request at different frequency, ideally we could still achieve average QPS load in each of the <code class="language-plaintext highlighter-rouge">nginx-deployment</code> Pods.</p>

<p>This is so-called the <strong>L7 (Application) Layer</strong> load balancing, and this is the ability we would want from the Istio service mesh solution.</p>

<p>Not all of types the requests can benefit from the traffic management. For example, if you have a service app serves as TCP server and use custom Protocol, istio can not do that much to help with the load balancing. HTTP Protocol can be managed in this way because it’s a “stateless” protocol, so <code class="language-plaintext highlighter-rouge">istio-proxy</code> can route the requests from the same client to different destination.</p>

<h3 id="load-balancing-tuning-with-istio">Load balancing tuning with Istio</h3>

<p>Once we realized that istio has the ability to manage traffic in L7 layer, we probably wanted to tune it to satisfy our application’s characteristics.</p>

<p><a href="https://istio.io/latest/docs/reference/config/networking/destination-rule/">DestinationRule</a> is the key setting to tune traffic loadbalancing in L7 layer. It offers varities of configurations for users from simple strategies to advanced ones.</p>

<h4 id="simple-load-balancing">Simple load balancing</h4>
<p>Most of the users would be satisified <a href="https://istio.io/latest/docs/reference/config/networking/destination-rule/#LoadBalancerSettings-SimpleLB">standard load balancing algorithms</a> provided by Istio, that require no tuning.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DestinationRule</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-dr</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">trafficPolicy</span><span class="pi">:</span>
    <span class="na">loadBalancer</span><span class="pi">:</span>
      <span class="na">simple</span><span class="pi">:</span> <span class="s">ROUND_ROBIN</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">LEAST_REQUEST</code> and <code class="language-plaintext highlighter-rouge">ROUND_ROBIN</code> would be the most practical algorithms that you might want to adapt to make the requests evenly distributed in your workloads. 99% of the time it is enough to do so.</p>

<h4 id="consistent-hash-load-balancing">Consistent hash load balancing</h4>

<p>Sometimes, you may want the traffic with the same characteristics to go to the same Pod for some reasons. For example, you may have in memory cache that may speed up the subsequential requests from the same user, or you may support resume from break-point for the same file uploads, etc.</p>

<p>To satisfy the the requirement of traffic “stickness”, istio offers <code class="language-plaintext highlighter-rouge">consistentHash</code> strategy to let you to configure to use some of the traffic’s information - header, cookie, ip, etc. as the source for calculating hash, any traffic hashed to the same bucket would go to the same destination pod. Following is a simple example to use a specific header for consistent hash.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DestinationRule</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-dr</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">trafficPolicy</span><span class="pi">:</span>
    <span class="na">loadBalancer</span><span class="pi">:</span>
      <span class="na">consistentHash</span><span class="pi">:</span>
        <span class="na">httpHeaderName</span><span class="pi">:</span> <span class="s2">"</span><span class="s">my-header"</span>
</code></pre></div></div>
<p>Notice that: 1. <code class="language-plaintext highlighter-rouge">consistentHash</code> is only best effort, it will be impacted by pods scale up / down. 2. After applying this strategy, you may experience traffic imbalance due to the nature of user traffic distribution. More settings can be referenced in <a href="https://istio.io/latest/docs/reference/config/networking/destination-rule/#LoadBalancerSettings-ConsistentHashLB">the official documentation</a></p>

<h3 id="traffic-management---routing">Traffic Management - Routing</h3>

<p>After checking out the above settings, you might be pretty amazed by Istio already. But these are not enough to make Istio a good service mesh solution.</p>

<p>One senario we leverage Istio for advanced traffic management is for release management.</p>

<p>To extend then nginx example in previous sections, now suppose we already have a <code class="language-plaintext highlighter-rouge">nginx-deployment</code> deployment that is using nginx:3.24, and we would like to upgrade it to use nginx:3.25. How would you approach it?</p>

<p>The simpliest way is to just editing the original deployment’s pod spec, and switch the image from <code class="language-plaintext highlighter-rouge">nginx:3.24</code> to <code class="language-plaintext highlighter-rouge">nginx:3.25</code>, once you’ve done the operation, kuernetes will automatically trigger a rollout restart of the <code class="language-plaintext highlighter-rouge">nginx-deployment</code>, and old pods with 3.24 version will be terminated, and new pods with 3.25 version will be created.</p>

<p>This works for some non-essential applications which you are either very confident to do a direct rollout or you are tolerant to temporary service down time so that you can easily rollback by switch the image version back.</p>

<p>Sometimes your application is essential, and you definitely do want to do a phase rollout - you may want to test new version first with a small portion of traffic, and ramp up the traffic to new version higher, and eventually 100% to the new version if everything is good; Otherwise, you might want to ramp down the traffic to 0% to the new version, and 100% to the old version.</p>

<p>It is possible to achieve this without service mesh solutions, but not perfectly. Let’s say we could always create multiple deployments of our applications with different versions.</p>

<p>For example, we create a <code class="language-plaintext highlighter-rouge">nginx-deployment-v1</code> deployment with <code class="language-plaintext highlighter-rouge">nginx:3.24</code> image.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-deployment-v1</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>   
      <span class="na">version</span><span class="pi">:</span> <span class="s">1</span>  
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">version</span><span class="pi">:</span> <span class="m">1</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:3.24</span>
</code></pre></div></div>
<p>And we create another deployment <code class="language-plaintext highlighter-rouge">nginx-deployment-v2</code> with <code class="language-plaintext highlighter-rouge">nginx:3.25</code> image.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-deployment-v2</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">0</span>
  <span class="na">selector</span><span class="pi">:</span>
    <span class="na">matchLabels</span><span class="pi">:</span>
      <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
      <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">nginx:3.25</span>
</code></pre></div></div>

<p>The two deployments have the same label <code class="language-plaintext highlighter-rouge">app: nginx-service</code>, so the <code class="language-plaintext highlighter-rouge">nginx-service</code> Service will recogonize both deployment’s apps.</p>

<p>We first will let <code class="language-plaintext highlighter-rouge">nginx-deployment-v2</code> to have 0 replicas, therefore TCP connections to <code class="language-plaintext highlighter-rouge">nginx-service.namepace.svc.cluster.local</code> are all with <code class="language-plaintext highlighter-rouge">nginx-deployment-v1</code> Pods. As we want to ramp up new version traffic, we could increase <code class="language-plaintext highlighter-rouge">nginx-deployment-v2</code> Pod replicas to 1, therefore there will be 3 <code class="language-plaintext highlighter-rouge">nginx-deployment-v1</code> pods and 1 <code class="language-plaintext highlighter-rouge">nginx-deployment-v2</code>, with the native kubernetes service load balancing, there is 25% possibility client Pods connecting to v2 pod and 75% possibility connecting to v1 pods. We could keep increaseing v2 pods replicas and reduce v2 pods replicas, until finally v1 pods scale down to 0, all traffic will go to v2 pods. If we find problems with v2 pods, we can revert the operation.</p>

<p><img src="http://localhost:4000/assets/imgs//03-http-imbalanced-route.svg" alt="HTTP Imbalanced Trffic" style="display: block; width: 59%; margin: auto; background: white;" /></p>

<p>This process is just fine for normal release requrement, which you will have sort of the live / canary mechanism to test the new rollout. But this is not perfect because the granularity of the ramp up / down can not be precisely controlled.</p>

<p>First of all, we have 3 replicas of old pods, so even ramping up 1 new pod will cause ~25% connections connecting to the new Pod.</p>

<p>Secondly, due to the L4 layer load balancing limitation, even if we setup old / new pods to be 3 : 1, the actual HTTP request % may diverge due to some clients calling more / less frequently.</p>

<p>How could Istio manage the routing better?</p>

<p>Istio would allow we define different “subsets” of a service by adding name with label selectors in <code class="language-plaintext highlighter-rouge">DestinationRule</code> - Remember we used this resource in above sections for load balancing? It can also be used for categorizing the service pods.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">DestinationRule</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-dr</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">subsets</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">v1</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">version</span><span class="pi">:</span> <span class="m">1</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">v2</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">version</span><span class="pi">:</span> <span class="m">2</span>
</code></pre></div></div>

<p>The above config setup 2 subsets of nginx-service, the <code class="language-plaintext highlighter-rouge">v1</code> subset containing nginx:3.24, and <code class="language-plaintext highlighter-rouge">v2</code> subset containing nginx:3.25.</p>

<p>After setting up DestinationRule, we setup a <code class="language-plaintext highlighter-rouge">VirtualService</code> resource to define the route behavior.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-vs</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">http</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
          <span class="na">subset</span><span class="pi">:</span> <span class="s">v1</span>
        <span class="na">weight</span><span class="pi">:</span> <span class="m">99</span>
    <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
          <span class="na">subset</span><span class="pi">:</span> <span class="s">v2</span>
        <span class="na">weight</span><span class="pi">:</span> <span class="m">1</span>
</code></pre></div></div>
<p>We defined <code class="language-plaintext highlighter-rouge">http.route</code> config in VirtualService and let 99% of the http requests goes to <code class="language-plaintext highlighter-rouge">v1</code> subset, and 1% of the traffic goes to <code class="language-plaintext highlighter-rouge">v2</code> subset.</p>

<p><img src="http://localhost:4000/assets/imgs/03-http-balanced-route.svg" alt="HTTP Imbalanced Trffic" style="display: block; width: 59%; margin: auto; background: white;" /></p>

<p>The client app’s <code class="language-plaintext highlighter-rouge">istio-proxy</code> will based on the <code class="language-plaintext highlighter-rouge">VirtualService</code> setting, to control the traffic split behavior. For example, if a client app sends 100 requests, 99 requests would go to v1 pods, 1 request would go to v2 pods. So even we have 3 v1 pods, and 1 v2 pods, we could still achieve 1% traffic split safely.</p>

<h3 id="advanced-traffic-route-rules">Advanced traffic route rules</h3>

<p>We see how the combination of VirtualService and DestinationRule controls the traffic split to v1 / v2 nginx nicely, but this is not the only ability of it.</p>

<p>Sometimes you want to test certain endpoints with specfic subsets - for example you want a certain URL pattern goes to some pods.</p>

<p>It’s very straightforward in <code class="language-plaintext highlighter-rouge">VirtualService</code> config that you can add <code class="language-plaintext highlighter-rouge">match</code> rules in <code class="language-plaintext highlighter-rouge">http.route</code>.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-vs</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">http</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">match</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">uri</span><span class="pi">:</span>
        <span class="na">prefix</span><span class="pi">:</span> <span class="s2">"</span><span class="s">/v2"</span>
      <span class="na">route</span><span class="pi">:</span>
        <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
          <span class="na">subset</span><span class="pi">:</span> <span class="s">v2</span>
    <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
          <span class="na">subset</span><span class="pi">:</span> <span class="s">v1</span>
</code></pre></div></div>

<p>The above config would make it possible that:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">curl http://nginx-service.namespace.svc.cluster.local/v2</code> goes to v2 pods</li>
  <li>Other requests goes to v1 pods</li>
</ol>

<p>Another common senario is that, you have a public facing web service, and before rolling out the new version, you want test the new versions on your browser using same urls, but “normal” users still access the old version.</p>

<p>A simple way to let Istio to identify “test” traffic would be adding a <code class="language-plaintext highlighter-rouge">debug=</code> cookie, and the requests with the cookie set would go to the new version.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">networking.istio.io/v1alpha3</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">VirtualService</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx-service-vs</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service.namespace.svc.cluster.local</span>
  <span class="na">http</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">match</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">headers</span><span class="pi">:</span>
          <span class="na">cookie</span><span class="pi">:</span>
            <span class="na">regex</span><span class="pi">:</span> <span class="s">^(.*?;)?\s*(debug=1)\s*(;.*)?$</span>
      <span class="na">route</span><span class="pi">:</span>
        <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
          <span class="na">subset</span><span class="pi">:</span> <span class="s">v2</span>
    <span class="pi">-</span> <span class="na">route</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">destination</span><span class="pi">:</span>
          <span class="na">host</span><span class="pi">:</span> <span class="s">nginx-service</span>
</code></pre></div></div>
<p>The setup is still using <code class="language-plaintext highlighter-rouge">match</code> rules, but instead of depending on <code class="language-plaintext highlighter-rouge">uri</code> matching, to use <code class="language-plaintext highlighter-rouge">headers</code> for matching. Cookie is 1 of the special header in HTTP protocol so it could be used.</p>

<p>A few more interesting rules can be found in <a href="https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest">official documentation</a>.</p>

<h2 id="traffic-management---more-to-explore">Traffic Management - more to explore</h2>

<p>By reading until here, I hope you’ve realized that why Istio is a <strong>better</strong> solution for traffic management - Its implementing L7 (Application) layer proxy is the key magic. Traffic management on the L4 (Transportation) layer have very limited flexibilities because it doesn’t have the higher layer’s information (Request, URL, Cookie, etc)</p>

<p>In this artical, we’ve checked a few example of Istio doing traffice management around load balancing and routing, but there are more things we could tweak with Istio, like retries, outlier detection, etc. We will touch these points in following articles.</p>


        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2023-11-20T18:00:00+08:00">November 20, 2023</time></p>


      </footer>

      <section class="page__share">
  

  <a href="https://twitter.com/intent/tweet?text=L4+Vs+L7%20http%3A%2F%2Flocalhost%3A4000%2Fistio%2F2023%2F11%2F20%2FL4-Vs-L7.html" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2Fistio%2F2023%2F11%2F20%2FL4-Vs-L7.html" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fistio%2F2023%2F11%2F20%2FL4-Vs-L7.html" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/istio/2023/11/20/Istio-Vs-Envoy.html" class="pagination--pager" title="Istio Vs Envoy
">Previous</a>
    
    
      <a href="/istio/2023/11/20/Tuning-Istio.html" class="pagination--pager" title="Tuning Istio
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You May Also Enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Tuning-Istio.html" rel="permalink">Tuning Istio
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Some of the new users of service mesh solutions including myself may think that network connections would be improved by just introducing the solution. This ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Istio-Vs-Envoy.html" rel="permalink">Istio Vs Envoy
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">If you looked at the documentation of Istio, this terminology envoy appears multiple ones. Also, there are some concepts like EnvoyFilter  that you might com...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/istio/2023/11/20/Introduction.html" rel="permalink">Introduction
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">I started to get in touch with Istio from 2020, when the Istio version was still around 1.6-ish. I was not the person who introduced Istio to the company, th...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/envoy/2021/07/30/How-do-we-use-Envoy-to-improve-PHP-Redis-client-performance.html" rel="permalink">How Do We Use Envoy To Improve Php Redis Client Performance
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Redis plays a very important role in Houzz’s technical stack - we used it for as  key-value storage, caching layer, queue system, etc.

</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2023 Yangyang' Blog. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
